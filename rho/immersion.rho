// Immersion contract
// store song & metadata, including artists to remunerate; return songid
// retrieve song given songid
// retrieve set of songs, metadata, & corresponding songids
// get new userid with 50 plays
// play(songid, userid): if (remaining user plays > 0) { decrement user plays, increment song plays, return allowed } else { return denied }
// getPlaysRemaining(userid)


new metaDataMapStore, songMapStore, userMapStore, remunerate in {
  // Maps songId to [metadata, songDataId]
  metaDataMapStore!({}) |
  // Maps songDataId to songData
  songMapStore!({}) |
  // Maps userId to remaining play count
  userMapStore!({}) |
  
  // songDataIn: arbitrary, usually bytearray
  // songMetaDataIn: map
  // songIdOut: name on which new songId (ByteArray) gets sent
  contract @["Immersion", "store"](@songDataIn, @songMetadataIn, songIdOut) = {
    new songName, songDataId in {
      for (@metaDataMap <- metaDataMapStore; @songMap <- songMapStore) {
        // issue why bother with ByteArray for songDataId?
        metaDataMapStore!(metaDataMap.set(*songName.toByteArray(), [songMetadataIn, *songDataId.toByteArray()])) |
        songMapStore!(songMap.set(*songDataId, *songDataId.toByteArray())) |
        songIdOut!(*songName.toByteArray())
      }
    }
  } |
  
  // songIdIn: bytearray
  // songDataOut: name on which songData gets sent
  contract @["Immersion", "retrieve"](@songIdIn, songDataOut) = {
    for (@metaDataMap <- metaDataMapStore; @songMap <- songMapStore) {
      metaDataMapStore!(metaDataMap) |
      songMapStore!(songMap) |
      songDataOut!(songMap.get(metaDataMap.get(songIdIn).nth(1)))
    }
  } |
  
  // metaDataMapOut: name on which to send map from song ids to metadata
  contract @["Immersion", "retrieve"](metaDataMapOut) = {
    for (@metaDataMap <- metaDataMapStore) {
      metaDataMapStore!(metaDataMap) |
      metaDataMapOut!(metaDataMap)
    }
  } |
  
  // userIdOut: name on which to send new user id (ByteArray)
  contract @["Immersion", "newUserId"](userIdOut) = {
    new userName in {
      for (@userMap <- userMapStore) {
        userMapStore!(userMap.set(*userName.toByteArray(), 50)) |
        userIdOut!(*userName.toByteArray())
      }
    }
  } |
  
  // songIdIn: bytearray
  // userIdIn: bytearray
  // permittedOut: boolean
  contract @["Immersion", "play"](@songIdIn, @userIdIn, permittedOut) = {
    for (@metaDataMap <- metaDataMapStore; @userMap <- userMapStore) {
      metaDataMapStore!(metaDataMap) |  // peek

      new playsRemainingOut in {
        playsRemainingOut!(userMap.get(userIdIn)) |
        for (@playsRemaining <- playsRemainingOut) {
          new mdOut in {
            mdOut!(metaDataMap.get(songIdIn)) |
            for (@md <- mdOut) {
              if (playsRemaining == Nil or playsRemaining == 0 or md == Nil) {
                userMapStore!(userMap) |
                permittedOut!(false)
              } else {
                userMapStore!(userMap.set(userIdIn, playsRemaining - 1)) |
                remunerate!(md.nth(0), Nil) |  // ISSUE: no need for sequencing, right?
                permittedOut!(true)
              }
            }
          }
        }
      }
    }
  } |
  
  // userIdIn: bytearray
  // countOut: name on which the reamining play count is sent
  contract @["Immersion", "playCount"](@userIdIn, countOut) = {
    for (@userMap <- userMapStore) {
      userMapStore!(userMap) |
      countOut!(userMap.get(userIdIn))
    }
  } |

  // ISSUE: are mints and purses and such worthwhile for the demo?
  new mintStore, zeroNNStore, pubKeyToPurseStore, debug(`rho:io:stderr`) in {
    @"MakeMint"!(*mintStore) |
    @["MakeMint", "int2NN"]!(0, *zeroNNStore) |
    pubKeyToPurseStore!({}) |

    debug!("contract remunerate...") |
    contract remunerate(@metaData, done) = {
      debug!(["remunerate:", metaData]) |

      for (@mint <- mintStore) {
        mintStore!(mint) | // peek
        debug!(["mint:", mint]) |

        new payEach, payOne in {
          // ISSUE: what if metaData is not a map?
          // ISSUE: what if there is no songWriters key?
          for (@start <- pubKeyToPurseStore) {
            payEach!(metaData.get("songwriters"), start) |

            contract payEach(@writers, @current) = {
              debug!(["payEach:", writers, current]) |
              // ISSUE: what if writers is not a list?
              match writers {
                [artist, ...rest] => {
                  new newPurseMapOut in {
                    payOne!(artist, current, *newPurseMapOut) |
                    for (@newPurseMap <- newPurseMapOut) {
                      payEach!(rest, newPurseMap)
                    }
                  }
                }
                [] => {
                  pubKeyToPurseStore!(current) |
                  done!(Nil)
                }
              }
            } |
            contract payOne(@artist, @current, newPurseMapOut) = {
              debug!(["payOne:", artist]) |
              new maybeMyPurseOut, myPurseOut, shareNNOut, paymentPurseOut in {
                @["MakeMint", "int2NN"]!(artist.get("share"), *shareNNOut) |
                for (@shareNN <- shareNNOut) {
                  @[mint, "makePurse"]!(shareNN, *paymentPurseOut) |

                  // ISSUE: what if artist has no pubKey?
                  maybeMyPurseOut!(current.get(artist.get("pubKey"))) |
                  for (@maybeMyPurse <- maybeMyPurseOut; @zeroNN <- zeroNNStore) {
                    zeroNNStore!(zeroNN) |
                    if (maybeMyPurse == Nil) {
                      @[mint, "makePurse"]!(zeroNN, *myPurseOut) |
                      for (@peek <- myPurseOut) {
                        debug!(["new purse for:", artist.get("name")]) |
                        myPurseOut!(peek) |
                        newPurseMapOut!(current.set(artist.get("pubKey"), peek))
                      }
                    } else {
                      debug!(["already have purse for:", artist.get("name")]) |
                      myPurseOut!(maybeMyPurse) |
                      newPurseMapOut!(current)
                    }
                  } |
                  for (@myPurse <- myPurseOut; @paymentPurse <- paymentPurseOut) {
                    debug!(["paying", artist.get("share"), " to ", artist.get("name")]) |
                    @[myPurse, "deposit"]!(shareNN, paymentPurse, Nil) // ISSUE: wait for ack?
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
