// Immersion contract
// store song & metadata, including artists to remunerate; return songid
// retrieve song given songid
// retrieve set of songs, metadata, & corresponding songids
// get new userid with 50 plays
// play(songid, userid): if (remaining user plays > 0) { decrement user plays, increment song plays, return allowed } else { return denied }
// getPlaysRemaining(userid)


new metaDataMapStore, songMapStore, userMapStore, remunerate in {
  // Maps songId to [metadata, songDataId]
  metaDataMapStore!({}) |
  // Maps songDataId to songData
  songMapStore!({}) |
  // Maps userId to remaining play count
  userMapStore!({}) |
  
  // songDataIn: arbitrary, usually bytearray
  // songMetaDataIn: map
  // songIdOut: name on which new songId (ByteArray) gets sent
  contract @["Immersion", "store"](@songDataIn, @songMetadataIn, songIdOut) = {
    new songName, songDataId in {
      for (@metaDataMap <- metaDataMapStore; @songMap <- songMapStore) {
        // issue why bother with ByteArray for songDataId?
        metaDataMapStore!(metaDataMap.set(*songName.toByteArray(), [songMetadataIn, *songDataId.toByteArray()])) |
        songMapStore!(songMap.set(*songDataId, *songDataId.toByteArray())) |
        songIdOut!(*songName.toByteArray())
      }
    }
  } |
  
  // songIdIn: bytearray
  // songDataOut: name on which songData gets sent
  contract @["Immersion", "retrieve"](@songIdIn, songDataOut) = {
    for (@metaDataMap <- metaDataMapStore; @songMap <- songMapStore) {
      metaDataMapStore!(metaDataMap) |
      songMapStore!(songMap) |
      songDataOut!(songMap.get(metaDataMap.get(songIdIn).nth(1)))
    }
  } |
  
  // metaDataMapOut: name on which to send map from song ids to metadata
  contract @["Immersion", "retrieve"](metaDataMapOut) = {
    for (@metaDataMap <- metaDataMapStore) {
      metaDataMapStore!(metaDataMap) |
      metaDataMapOut!(metaDataMap)
    }
  } |
  
  // userIdOut: name on which to send new user id (ByteArray)
  contract @["Immersion", "newUserId"](userIdOut) = {
    new userName in {
      for (@userMap <- userMapStore) {
        userMapStore!(userMap.set(*userName.toByteArray(), 50)) |
        userIdOut!(*userName.toByteArray())
      }
    }
  } |
  
  // songIdIn: bytearray
  // userIdIn: bytearray
  // permittedOut: boolean
  contract @["Immersion", "play"](@songIdIn, @userIdIn, permittedOut) = {
    for (@metaDataMap <- metaDataMapStore; @userMap <- userMapStore) {
      metaDataMapStore!(metaDataMap) |  // peek

      new playsRemainingOut in {
        playsRemainingOut!(userMap.get(userIdIn)) |
        for (@playsRemaining <- playsRemainingOut) {
          new mdOut in {
            mdOut!(metaDataMap.get(songIdIn)) |
            for (@md <- mdOut) {
              if (playsRemaining == Nil or playsRemaining == 0 or md == Nil) {
                userMapStore!(userMap) |
                permittedOut!(false)
              } else {
                userMapStore!(userMap.set(userIdIn, playsRemaining - 1)) |
                remunerate!(md.nth(0), Nil) |  // ISSUE: no need for sequencing, right?
                permittedOut!(true)
              }
            }
          }
        }
      }
    }
  } |
  
  // userIdIn: bytearray
  // countOut: name on which the reamining play count is sent
  contract @["Immersion", "playCount"](@userIdIn, countOut) = {
    for (@userMap <- userMapStore) {
      userMapStore!(userMap) |
      countOut!(userMap.get(userIdIn))
    }
  } |

  // ISSUE: are mints and purses and such worthwhile for the demo?
  new pubKeyToBalanceStore, debug(`rho:io:stderr`) in {
    pubKeyToBalanceStore!({}) |

    debug!("contract remunerate...") |
    contract remunerate(@metaData, done) = {
      debug!(["remunerate:", metaData]) |
      for (@start <- pubKeyToBalanceStore) {
        debug!(["start:", start]) |
        new payEach in {
          // ISSUE: what if metaData is not a map?
          // ISSUE: what if there is no songWriters key?
          payEach!(metaData.get("songwriters"), start) |

          contract payEach(@writers, @current) = {
            // debug!(["payEach:", writers, current]) |
            // ISSUE: what if writers is not a list?
            match writers {
              [first, ...rest] => {
                payEach!(rest,
                  // ISSUE: what if first has no pubKey?
                  current.set(first.get("pubKey"),
                    current.getOrElse(first.get("pubKey"), 0) + first.get("share")))
              }
              [] => {
                debug!(["finish:", current]) |
                pubKeyToBalanceStore!(current) |
                done!(Nil)
              }
            }
          }
        }
      }
    }
  }
}
